---
chapter: 5
title: "Eberban Predicates"
---
import DictEntry from "../../components/DictEntry";
import Info from "../../components/Info.astro";

Beginning with this chapter, we dive into how Eberban actually works.

Eberban has two overarching [word types](/chapters/word-types): particles and
content words. Some particles are content words and _all_ content words are
predicates.

Eberban predicates differ from Logic predicates. Henceforth, the usage of
"predicate" will refer to an Eberban predicate.

## Places 

<Info type="jargon" title="Places (AKA slots)">
Predicates are bound to arguments by places. We use them to express meaning with
more detail.

Places can bind any number of arguments to a predicate any number of times.
</Info>

Predicates have places.

The first of these places is called **the context**. It conveys some information
automatically, like tense (walked/walks/will walk). By design, the context is
always present yet hidden and not directly accessible. This lets us focus on
the meaning we want to express.

The others are called **overt places** and are represented by the vowels
\{E,A,O,U\}. They follow this order. For example, the vowels "E" and "A"
represent the first and second overt places of a predicate respectively.

All predicates have the context place and any number of overt places. Let's take
a look at one:

<Info type="examples">
<DictEntry client:load id="vgeqteao1c" /> {/* mian */}
</Info>

The property "mian" has one overt place `E`.

<Info type="reminder" title="Property">
A unary predicate is called a property. We recommend reviewing the
[logic chapter](/chapters/a-little-logic) if you still find this sort of jargon
confusing.
</Info>

## Arguments

Places have an argument quantity and an argument type. This informs us about
what kind of arguments a predicate may be bound to by its places.

"mian" is bound to any number of arguments of quantity `tce*` and type `pan` by
its `E` place.

### Quantity

Most arguments that you'll see will have their quantities expressed as sets.
Sets can either be collective or distributive.

<Info type="jargon" title="Collective Sets vs. Distributive Sets">
Set A is a subset of set B if the members of A are also members of B.

A collective set denotes an exact quantity of the argument type. This is
expressed by a root starting with `tc-`.

A distributive set denotes a plural quantity that also works for subsets of the
argument type. This is expressed with one of the `tc-` roots followed by `*`.
</Info>

The argument quantity of the `E` place of "mian" is `tce*`. `tce` denotes a
non-empty set, and `*` tells us that we can use any subset of this non-empty
set. This effectively means one or more.

<Info type="jargon" title="Quantity annotation">
This "one or more" quantity is so common that we'll suffix nouns and pronouns
with the symbol `+` to annotate them with said quantity.
</Info>

On the occasion you do see it, the lack of a `tc-` root denotes an unspecified
quantity. We'll teach ways to further specify quantity in a later chapter.

### Type

Arguments are either typed as atom or predicate.

**Atoms**

<Info type="jargon" title="Atoms">
Atoms are non-predicates; they have no intrinsic meaning. An atom acquires
meaning when a place binds said atom to its predicate. When bound, they're used to
represent anything from an idea to a cat. In this state, atoms can be considered
nouns.
</Info>

The argument at the `E` place of "mian" has the `pan` type. Which, if we look it
up:

<div class="my-4"><DictEntry client:load id="whi7bmezoy" /></div> {/* pan */}

Will tell us that the type is a physical entity. So "mian" is bound to a
physical entity+ by its `E` place.

**Predicates**

The predicate type is denoted with brackets. The number of letters inside the
brackets tells us the arity.

<Info type="examples">
<DictEntry client:load id="r7wbdwqgm0" /> {/* gli */}
</Info>

"gli" is bound to a physical entity+ by its `E` place, and to a proposition by
its `A` place.
